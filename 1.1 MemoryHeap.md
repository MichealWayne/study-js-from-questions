
# 1.1 Memory Heap/Stack(内存堆栈)
js引擎中对变量的存储主要有两种位置,堆内存和栈内存。由此对应了两大数据类型：
- 基本数据类型（Primitive）：Boolean、null、undefined、String、Number、Symbol(ES6)
- 引用数据类型（Object）：Array、Function、Object、RegExp、(Number|Boolean|String|Symbol)Object、Map(ES6)、Set(ES6)、Promise(ES6)、Date()、浏览器内置对象等。

为什么要分成堆内存和栈内存来存放变量呢？在计算机的数据结构中，栈比堆的运算速度更快，那么是否都能放在栈内存中呢？答案是否定的。像Array/Object等这种类型，其值的大小不固定，还能拓展，这种情景下不能把它们保存到栈内存中。因此需要将变量分成堆内存和栈内存来存放，然而引用类型的内存地址大小的固定的，因此这部分可以放在栈内存中。

堆内存和栈内存的区别不仅体现在引用和复制、赋值上，在内存分配和垃圾回收中也有着明显区别。这将在后续篇章进行详细介绍。
需要注意的一点是，栈内存不仅存储着各种基本类型的变量，还存放着对象变量的指针(访问地址)，在查询引用类型变量时，先从栈中读取变量指针，再通过地址找到堆中的值，这个过程称为按引用访问。

V8引擎中的数据类型结构如下。
![v8-data](../images/v8-data.png)

js里每个基本数据类型在v8里都有对应的类实现。我们知道，作为动态语言的js在编译时不能确定变量的类型，只能在执行时确定。在运行时计算和决定类型是会降低运行效率的原因。V8使用了一种特殊的方法：数据的内部表示由数据的实际内容和数据的句柄构成。数据的实际内容长度可变，类型可变；数据的句柄固定大小，包含指向数据的指针。变量存取时通过查找、修改句柄中的指针即可。

## 1.1.1 基本数据类型
### Q1.`typeof null === typeof {}`的结果及其原因
结果一目了然，返回`true`，因为两个typeof的结果都是`"object"`，那么为什么`typeof null`的结果是object而不是null呢？可以说是早期js的bug。

#### 数值存储标识
数值是以32字节存储的，由标志位（1~3个字节）和数值组成。标志位存储的是低位的数据。这里有五种标志位
- `000`：对象，数据是对象的应用。
- `1`：整型，数据是31位带符号整数。
- `010`：双精度类型，数据是双精度数字。
- `100`：字符串，数据是字符串。
- `110`：布尔类型，数据是布尔值。

有 2 个值比较特殊：
- `undefined`：用`（?2^30）`表示。
- `null`：对应机器码的 NULL 指针，一般是全零。

#### 数值判断
在早期的js引擎判断中，typeof进行数据类型的判断规则如下
``` c
if (JSVAL_IS_VOID(v)) {  // (1)
    type = JSTYPE_VOID;
} else if (JSVAL_IS_OBJECT(v)) {  // (2)
    obj = JSVAL_TO_OBJECT(v);
    if (obj &&
        (ops = obj->map->ops,
            ops == &js_ObjectOps
            ? (clasp = OBJ_GET_CLASS(cx, obj),
            clasp->call || clasp == &js_FunctionClass) // (3,4)
            : ops->call != 0)) {  // (3)
        type = JSTYPE_FUNCTION;
    } else {
        type = JSTYPE_OBJECT;
    }
} else if (JSVAL_IS_NUMBER(v)) {
    type = JSTYPE_NUMBER;
} else if (JSVAL_IS_STRING(v)) {
    type = JSTYPE_STRING;
} else if (JSVAL_IS_BOOLEAN(v)) {
    type = JSTYPE_BOOLEAN;
}
```

步骤可以理解为：
- 第一步，判断是否为 undefined；
- 第二步，如果不是 undefined，判断是否为对象；
- 第三步，如果不是对象，判断是否为数字；
- 第四步，如果不是数字，判断是否为字符串；
- 第五步，如果不是字符串，判断是否为布尔值。

这样来看，在typeof判断`null`的时候，第一步判断是否undefined时，标志位不匹配，到第二步，全是`0`的null符合`000`的标志，因为判断结果为对象。很是尴尬。

#### 后续会修改吗
个人觉得如果修改此判断的话会大范围影响早期网站。比如某网站对变量判断如下：
``` js
/**
 * 判断是否为false/null/undefined，虽然不推荐这么判断不过相信有这么写的
 * @param val {any} 变量
 * @return {Boolean}
 */
function isNoVal(val) {
	let _type = typeof val;
	if (!value && 
		(_type === 'boolean' || _type === 'object' || _type === 'undefined')
	) {
		return true;
	} else {
		return false;
	}
}
```

这种情况下如果typeof null 值为'null'的话那返回就是false了。


在 ES6 中也曾有关于修复此 bug 的提议，提议中称应该让`typeof null === 'null'`。但是该提议被无情的否决了，自此 typeof null 终于不再是一个 bug，而是一个 feature，并且永远不会被修复。

归纳：
- 关键词：**类型判断**
- 可拓展内容：几种比较方式的使用场景、比较和实现原理（`typeof`、`instanceof`、`Object.prototype.toString.call`、`Object.is`）。



### Q2.`var str1 = 'string', str2 = String('string'), str3 = new String('string');`，变量`str1`、`str2`和`str3`结果是相同的吗？如果不相同可能通过处理使其相同吗？

先上结果，`str1`和`str2`结果相同，但它们和`str3`不相同。
`str1`是最直接的字符变量赋值操作，结果是字符串`string`，`str2`是通过String构造函数进行字符串赋值操作，其结果也是字符串`string`，而通过new操作符定义的`str3`结果是什么呢？它返回一个对象，存取字符串、数字或者布尔值的属性时创建的临时对象称作包装对象。

`str3`在Chrome中打印如下：
``` 
String {"string"}
0: "s"
1: "t"
2: "r"
3: "i"
4: "n"
5: "g"
length: 6
__proto__: String
[[PrimitiveValue]]: "string"
```

既然`str3`是引用类型，那么它自然就跟字符类型不相等了。

那么`str3`还有机会转为我们所需要的字符串吗？答案是肯定的。我们可以通过`valueOf()`或`toString()`方法进行转换（`toString()`本身也会进行一步`valueOf()`，其转换规则见后文1.1.3类型转换）：
``` js
str3 = str3.valueOf();

// or
str3 = str3.toString();

console.log(str3);	// 'string'
```


关于new操作符后续操作符篇章会有更为详细的介绍，在此就不展开了。最后点一下隐式包装对象。

#### 隐式包装对象
基本类型本身不具备操作方法，就像字符串`str1`，它本身并不具备`slice()`、`charCodeAt()`等等字符操作方法，但我们为什么可以直接像`str1.slice(1, 3)`这样直接使用呢，这就涉及到一个隐式的转换，js引擎会隐式创建的包装对象，包装对象具备slice方法，然后在方法使用完毕后这个包装对象会被销毁掉。


归纳：
- 关键词：**包装对象**、**类型转换**。
- 拓展：包装对象的`valueOf`和`Symbol.toPrimitive`。


### Q3.分别说出以下比较的结果及原因：
``` js
console.log(3.0 === 3); 
console.log(+0 === -0); 
console.log(+Infinity === -Infinity);
console.log(NaN === NaN);
```

先上结果，分别是`true`、`true`、`false`、`false`。

#### `console.log(3.0 === 3)`
ES中Number类型使用IEEE754格式来表示整数和浮点数值（64为）。因为保存浮点数需要的内存空间是保存整数的两倍，因此ES会不失时机地将浮点数转换为整数值。也因此`3.0`会被转换为`3`，所以它们值是相等的。

#### `console.log(+0 === -0)`
首先来看`+0`、`-0`是怎么来的（os：都是零还分什么正负）。
- js中有一个常规的0，也叫作`+0`，也就是默认的零。`Number('0')`、`0 * 1`等等都会产生`+0`。
- `-0`的产生比较诡异，主要是以下几个方式`123 * -0`、`0 / -3`、`Number('-0')`、`JSON.parse( "-0" )`

为什么会产生`+0`和`-0`呢？其实又是IEEE 745的锅。浮点数的第一位是符号位，`0`为正，`1`为负，后面是具体数值。所以某些操作导致产生`0...0`(64个0)的`+0`或者说`0`，以及`10...0`(63个0)的`-0`。但零没有正负，所以就约定`+0`和`-0`相等。

##### 判断和比较
第一种方式是利用Infinity
``` js
function isNegZero(num){
    num = Number( num );
    return (num === 0) && (1 / num === -Infinity);
}
isNegZero( -0 );// true
isNegZero( 0 );// false
```

第二种就是利用ES6的Object.is()方法
``` js
function isNegZero (num) {
	num = Number( num );
	return Object.is(num, -0)
}
isNegZero( -0 );// true
isNegZero( 0 );// false
```


#### `console.log(+Infinity === -Infinity);`
首先来说js数值的无穷。
如果某次计算的结果得到了超过js数值范围（一般是5e-324~1.7976931348623157e+308）的值，这个值将被自动转换成特殊的Infinity值，负数为-Infinity（负无穷），正数为Infinity（正无穷）。

从定义上我们也可以得知他们是完全不相等的。


得到Infinity：
- 直接赋值：`var max = Infinity`；
- 根据定义：`var max = 1e6666666666`;
- 访问Number.NEGATIVE_INFINITY和Number.POSITIVE_INFINITY也可以得到负和正的Infinity值。

#### `console.log(NaN === NaN);`
not a number，这个数值表示一个本来要返回数值的操作数未返回数值的情况。
NaN这个数值也一直是本人认为是很诡异的一个值，一个不是数字的数值，什么鬼。

首先要来看它是数值这个特性，我们可以通过typeof：`typeof NaN`的返回是`"number"`、`Object.prototype.toString.call(NaN)`的返回是`"[object Number]"`。这么看来，NaN确实是数值类型。
再来看它不是数字，这就是它的定义，也正因为非数字的特性导致它跟任何数字操作返回都是NaN，如`NaN + 1`。那么如何理解NaN != NaN呢，其实还是需要从定义上，“本来要返回数值的操作数未返回数值的情况”，从某种程度来说NaN是个未知值，未知值与未知值自然是不相等的。

##### 判断是否为NaN
第一种方式是isNaN()方法

第二种是通过ES6的Object.is()方法
``` js
Object.is(NaN, NaN)
```

归纳：
- 关键词：**Number**
- 拓展：了解IEEE 754规范、整数和浮点数的存储区别。


### Q4.什么是Number的安全整数？以下运算操作的结果是什么？
``` js
var num = Math.pow(2, 60);
console.log(num);
num++;
console.log(num);
num -= Math.pow(2, 59);
console.log(num);
```

回答：js 能够准确表示的整数范围在-2^53到2^53之间（不含两个端点），超过这个范围，无法精确表示这个整数。也就是说，在这个范围之间的整数就是安全整数。
上面运算的操作返回结果依次分别是：`1152921504606847000`、`1152921504606847000`、`6 576460752303423500`。

当我们设置的数值超出安全整数的范围时，数值操作会因为溢出出现问题。从直接的运行结果（V8）来看，操作超出安全整数范围的数值时，如果结果也是非安全整数，那么仍然保留原始值；如果结果是安全整数，那么返回正常的操作结果。当然个人觉得这与平台有关。

由此我们也需要注意，在涉及到数值较大的处理中，我们要注意其安全性，我们可以通过Number.isSafeInteger()方法进行安全整数的判断。或者直接用很多优秀的第三方库来解决该问题：bignum、bigint。


归纳：
- 关键词：**Number**
- 拓展：IEEE 754数值的存储规则。


### Q5.以下代码数据赋值运行都会报错吗？顺带说说`undefined`和`null`的区别
``` js
var undefined = 'undefined';
var null = 'null';
```

回答：undefined赋值不会报错，null赋值会报错（`Uncaught SyntaxError: Unexpected token null`）。

首先undefined和null都不是规范里的关键字和保留字，但浏览器理应对其赋值操作进行控制（[mdn-关键字](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Lexical_grammar#%E5%85%B3%E9%94%AE%E5%AD%97)：“null、true和false同样不能被当成标识使用。”），undefined一方面是早期版本被遗忘，还有一方面个人认为是因为undefined是全局属性（window.undefined可访问），因此var操作在语句解析的过程中被默认忽略。

既然赋值操作不会报错，那么undefined的值会被改么？
在我的试验中，早期IE确实会改版undefined的值，因此也有了对于undefined的特殊安全判断（可见《你不知道的js-闭包》），后期浏览器undefined的值不会修改。

对其赋值操作这个也算是个bug，但与typeof一样如果在后续版本对此操作报错会大范围得影响早期页面。

归纳：
- 关键词：**关键字和保留字**
- 拓展：撸一遍ES各版本以来的关键字和保留字。

### Q6.以下代码执行输出的结果是什么？
``` js
var x = new Boolean(false);
if (x) {
    console.log('true');
} else {
    console.log('false');
}
```

回答：`"true"`
与Q3情况一样，也是包装对象的原因。存取字符串、数字或者布尔值的属性时创建的临时对象称作包装对象。因此x的值也是一个引用类型。

在Chrome中打印如下：
```
Boolean {false}
__proto__: Boolean
[[PrimitiveValue]]: false
```

为什么单独拎一个问题出来呢？因为这个判断从逻辑上是不符合我们认知的，我们创建了一个“非”的Boolean值，凭什么在判断里是true。这点是容易误导人的。当然，我们可以通过valueOf()方法将包装对象转为真实的布尔值。
``` js
x = x.valueOf();
if (x) {
    console.log('true');
} else {
    console.log('false');
}

// 结果：'false'
```

总而言之，不推荐用构造函数来创建Number/String/Boolean。


归纳：
- 关键词：**包装对象**。
- 拓展：还是包装对象的`valueOf`和`Symbol.toPrimitive`。

###  Q7.`NaN、null、undefined、true/false、Infinity`中哪些能通过全局属性取值？如浏览器`window.NaN`、nodeJs`global.null`

回答：`NaN`、`undefined`、`Infinity`可以通过全局属性取值。

它们的属性特性：
- writable：false
- enumerable：false
- configurable：false

（undefined在早期是writable的，上文有提到）

归纳：
- 关键词：**全局属性**
- 拓展：全局属性和全局变量，有区别吗？


### Q8.除了使用模板字符串外，如何通过最快的方式解决以下字符串赋值报错的问题
``` js
var longString = "This is a long String
i need to wrap across multiple lines and don't want to keep in a row
because it's unreadable.";
```

回答：可以通过转义字符`/`。
很多人会想到用ES6的模板字符串，但是模板字符串通过babel转为ES5时会增加`\n`换行符，有时候我们也不需要这个换行符。这种情况下，我们可以通过直接加转义字符来控制。如
``` js
var longString = "This is a long String\
i need to wrap across multiple lines and don't want to keep in a row\
because it's unreadable.";
```

归纳：
- 关键词：**字符操作**
- 拓展：上面这串字符串代码压缩后会合成一行吗？为什么；撸一遍转义字符及应用场景。

### Q9.关于Symbol，为什么`Symbol()`不能用new来定义？`console.log(Symbol.length, String.length, Number.length)`的输出是什么？Symbol能转换为数值吗？

#### 不能用new创建
其实还算是包装对象的原因，因为new操作符导致混淆（如Q3、Q6），因此在ES推出Symbol的时候将`new Symbol()`进行错误处理（`Uncaught TypeError: Symbol is not a constructor`）。避免了new Symbol结果为引用类型的情况。

#### `console.log(Symbol.length, String.length, Number.length)`
结果是`0,1,1`。构造函数的length指其参数值，String和Number都好理解，但Symbol.length为什么是0呢，个人认为是因为Symbol这个数据类型的特殊性。

#### Symbol能转换为数值吗？
结果是不能。当你尝试将一个symbol值进行数值转换时，会抛出错误(TypeError)。如
``` js
+Symbol();		// error
Number(Symbol(1));	// error
parseInt(Symbol('aaa')); // error
```

但要留意的是，除了parseInt()转化外，其他的错误信息都是`Uncaught TypeError: Cannot convert a Symbol value to a number`，而parseInt()的错误信息是`Uncaught TypeError: Cannot convert a Symbol value to a string`。

为什么呢，因为parseInt()会先进行转字符串的操作，具体见后文类型转换。

归纳：
- 关键词：**Symbol**
- 拓展：撸一遍Symbol的方法和属性，看看Symbol的prototype。

## 1.1.2 引用类型
### Q1.分别`new Array(4)`和`[,,,]`定义数组的结果是一样的吗？

### Q2.数组最大长度是多少？超出会如何

### Q3.`console.log(Date.length, Function.length, Array.length, Object.length)`的输出是什么？


## 1.1.3 类型转换与相等比较
### Q1.以下语句会报错吗？如果报错如何最简单进行调整？
``` js
var numstr1 = 6.6.toFixed(2);
var numstr2 = 6.toFixed(2);
```

### Q2.`2.55.toFixed(2) === '2.56'`的判断输出是什么

### Q3.说出以下转换数字数值转换的结果：
``` js
// parseInt
parseInt('123.456.789');
parseInt('123abc');
parseInt(123.456, 36);
parseInt(123.456, 2);
parseInt(123.456, 1);

// parseFloat
parseFloat('123.456.789');
parseFloat('123abc.456.789');

// Number
Number('123a.456');
Number('0x11');
Number('0b11');
Number('0o11');

// Math.round
Math.round('123a.456');
```

### Q4.`parseInt()`/`parseFloat()`/`Number()`/`Math.round()`做数值转换时的效率排行顺序，可以的话解释下原因并说明相关应用场景。


## 1.1.4 动态语言和Duck typing


## 1.1.5 赋值和变量提升

## 1.1.6 执行上下文

## 1.1.7 作用域和作用域链

## 1.1.8 闭包和IIFE

## 1.1.9 浅拷贝、深拷贝

## 1.1.10 垃圾回收


------------------
反馈和转载请联系作者：[michealwayne@163.com](mailto:michealwayne@163.com)